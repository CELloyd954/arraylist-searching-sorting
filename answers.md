Search questions:

1) 
- the first algorithm, in which I just looked through the objects, was a lot quicker and easier than continually splitting the line in half

2)
- to me, an algorithm is effiecient if performs its function in the qickest possible way that still works perfectly
- the search algortihm seems to be the most efficient way

3)
i.
- the search algorithm would start at the beginning and go through the list until it found "blueberry", most-likely sing a for-loop
- the binary algorithm would start in the middle (length / 2), which would start with either "lemon" or "lime", and since neither of those is "blueberry", it would go through the first half of the list, and if "blueberry" is there, it would divide the first half in two, but since "blueberry" isn't in the list, it would keep cutting the limited lists in half until it isn't possible

ii.
- 11
- 11, but some more times than others, and depending on where "blueberry" is, in this case it's not there, the algorithm can access different amounts of variables

iii.
- for search, it would access however many variables existed up until it found what it's looking for
- for binary, it would once again depend on where the item it is looking for can be found, so the answer is impossible to determine without viewing the list


Sort questions:

1)
iv.
- all three algorithms seem to be about as efficient as the other
- all three are relatively quick and easy to perform
- personally I instinctively used selectionSort

2)
i.
- selectionSort: 55 comparisons of two (comparing object to smallest 10x, then 9x, then 8x, etc)
- insertionSort: 10 comparisons of two (item compared to the item to its immediate left, and no more, sice theyre already in order)
- bubbleSort: 9 comparisons of two (doesn't go all the way to the end of the list, but the object one before the end)

ii.
- selectionSort: 55 comparisons of two
- insertionSort: 45 comparisons
- bubbleSort: 90 comparisons of two (doesn't go all the way to the end of the list, but the object one before the end, cycles through 10x)

iii.
- selectionSort: 55 comparisons of two every time
- insertionSort: probably between 25-30, about the middle of 10 (the lowest possible), and 45 (the highest possible)
- bubbleSort: 50 ish, not perfectly in or out of order, but somewhere in the middle

3)
- using normal search is probably easier, as it doesn't need the list to be in order, and it doesn't require you to sort the list, but binary search would require sorting the list first